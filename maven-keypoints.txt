//////////////////////################  MAVEN POINTS ################////////////////////////////////////

Life cycle is a sequence of named phases.
Maven is based around the central concept of a build lifecycle.
There are three built-in build lifecycles:
1. default(build)
2. clean
3. site

1. Default Build Phases: Each Build Lifecycle is Made Up of Phases.Phases execute sequentially. Executing a phase means executes all previous phases. Maven Default(Build) Lifecycle has following phases:
a. Validate - validate the project is correct and all necessary information is available
	b. compile - compile the source code of the project
	c. test - test the compiled source code using a suitable unit testing framework. 
                   These tests should not require the code be packaged or deployed
	d. package - take the compiled code and package it in its distributable format, such as a JAR.
	e. verify   - run any checks to verify the package is valid and meets quality criteria
	f. install - install the package into the local repository, 
                   for use as a dependency in other projects locally
	g. deploy - done in an integration or release environment, copies the final package to the 
                  remote repository for sharing with other developers and projects.

2. Clean Phases:
	a. pre-clean	execute processes needed prior to the actual project cleaning
	b. clean	remove all files generated by the previous build
	c. post-clean	execute processes needed to finalize the project cleaning

3. Site Lifecycle
	a. pre-site	execute processes needed prior to the actual project site generation
	b. site	             generate the project's site documentation
	c. post-site	execute processes needed to finalize the site generation, and to prepare for 
                                       site deployment
	d. site-deploy	deploy the generated site documentation to the specified web server

So to go through the above phases, we just have to call one command:
	mvn <phase> { Ex: mvn install }
For the above command, starting from the first phase, all the phases are executed sequentially till the ‘install’ phase. 
A command can be used in a multi-module scenario  mvn clean install.
Ex-
	mvn clean package site
	mvn clean install -P rpmOs



Maven Plugin :- Plugin is a collection of goals.For Example Plugin is a class and goals are methods within the class.
	Syntax.   mvn [plugin:goal]
	Ex.
	mvn javadoc:javadoc
	mvn javadoc:test-javadoc
	mvn dependency:tree
	mvn dependency:analyze
	mvn dependency:analyze-duplicate
	mvn dependency:list -Dsort=true
	mvn dependency:tree
	mvn help:effective-pom

Maven Key Points:
	a. Life Cycle:  3 Life Cycles (aka Build Lifecycles) - Default, Clean, Site.
	b. Phases:  Each Life Cycle is made up of Phases - e.g. For default lifecycle: compile, test, 
                                 package, install, etc
	c. Plugin:   Artifact that provide one or more goals. Based on packaging(jar,war,etc), a 
                                plugin:goal is bind to a phase. Details
	d. Goals:   The task (action) that executes. A plugin can have one or more goals. When 
                                configuring a plugin in a POM, goal needs to be specified. 
Additionally, in case a plugin definition does not have a default build phase, the phase can be specified/bind with the plugin goal.

Maven Dependency: There are two types of Maven dependencies:
	a. Direct: These are dependencies defined in your pom.xml file under the 
                              <dependencies/> section.
	b. Transitive: These are dependencies that are dependencies of your direct dependencies.

Dependency Scope: Dependency scope is used to limit the transitivity of a dependency, and also to affect the classpath used for various build tasks.
There are 6 scopes available:
1. compile : - This is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, those dependencies are propagated to dependent projects.
2. provided : -This is much like compile, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope provided because the web container provides those classes. This scope is only available on the compilation and test classpath, and is not transitive.
3. runtime : -This scope indicates that the dependency is not required for compilation, but is for execution. It is in the runtime and test classpaths, but not the compile classpath.
4. test : -This scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation and execution phases. This scope is not transitive.
5. system : -This scope is similar to provided except that you have to provide the JAR which contains it explicitly. The artifact is always available and is not looked up in a repository.
6. import (only available in Maven 2.0.9 or later) : - This scope is only supported on a dependency of type pom in the <dependencyManagement> section. It indicates the dependency to be replaced with the effective list of dependencies in the specified POM's <dependencyManagement> section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency.

Dependencies vs DependencyManagement :-
<dependencyManagement> allows to consolidate all dependencies (used at child pom level) used across different modules -- clarity, central dependency version management
       2.   <dependencyManagement> allows to easily upgrade/downgrade dependencies based on need, in other scenario this needs to be exercised at every child pom level -- consistency
       3.  dependencies provided in <dependencies> tag is always imported, while dependencies provided at <dependencyManagement> in parent pom will be imported only if child pom has respective entry

Create your own maven plugin:
1. Create Maven project in IDE using following name convension For example,
a. maven-${prefix}-plugin: 
This naming convention is restricted to the plugins developed by Maven.
	b. ${prefix}-maven-plugin: 
We can use this convention to create our custom plugins.
		
    <groupId>com.anupam</groupId>
    <artifactId>myfirst-maven-plugin</artifactId>
    <packaging>maven-plugin</packaging>
    <version>1.0-SNAPSHOT</version>
    <name>myfirst-maven-plugin</name>
2. Create One MOJO class
		@Mojo(name = "hello")
		public class MyMojo extends AbstractMojo {
			@Parameter(property = "msg",defaultValue = "from maven")
			private String msg;
			public void execute()
					throws MojoExecutionException {
				getLog().info("Hello " + msg);
			}
			//getter setter
		}
3. Use custom plugin in another project
	a. Attach your plug-in into this project as standalone without specifying phase in execution 	
	b. or attach this plug-in with existing life-cycle with specifying phase (compile,install ) in execution
4. execute plugin : There are two ways to execute the plugin.
	a. mvn groupId:artifactId:version:goal
	b. mvn myfirst:hello 
approach (b) is used to run the plugin is by omitting the group id and just specifying the artifact id along with the goal name. However, for this to happen, we have to add the group id to the default list of groups that Maven will look for. Open the file %MAVEN_HOME%/conf/settings.xml and add the following line under the element pluginsGroup.
	<pluginGroup>specify group-id here </pluginGroup>

